// Objective-C API for talking to valera.co/vdk Go package.
//   gobind -lang=objc valera.co/vdk
//
// File is generated by gobind. Do not edit.

#ifndef __VDK_H__
#define __VDK_H__

@import Foundation;
#include "ref.h"
#include "Universe.objc.h"


@class VDKAccount;
@class VDKAsset;
@class VDKBalance;
@class VDKBalanceKeys;
@class VDKBalanceValue;
@class VDKClarityList;
@class VDKClarityValue;
@class VDKPayload;
@class VDKPostCondition;
@class VDKPrincipal;
@class VDKStacksTransaction;
@class VDKWallet;

/**
 * Wrapper around [wallet.Account].
 */
@interface VDKAccount : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) VDKPrincipal* _Nullable principal;
/**
 * Get the *possible* next nonce.
 */
- (BOOL)nextNonce:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * Get underlying Account as a String.
 */
- (NSString* _Nonnull)raw;
@end

/**
 * FT or NFT
 */
@interface VDKAsset : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Create a new Asset (FT or NFT)
 */
- (nullable instancetype)init:(VDKPrincipal* _Nullable)contract name:(NSString* _Nullable)name;
@property (nonatomic) VDKPrincipal* _Nullable contract;
@property (nonatomic) NSString* _Nonnull name;
/**
 * Get the `Asset` as a string.
 */
- (NSString* _Nonnull)string;
@end

@interface VDKBalance : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Retrieve the balance of a user.
 */
- (nullable instancetype)init:(VDKPrincipal* _Nullable)principal;
/**
 * TODO(Linden): remove once golang/go#13445 is fixed.
 */
- (VDKBalanceValue* _Nullable)ftAt:(long)at error:(NSError* _Nullable* _Nullable)error;
- (long)ftLength;
- (VDKBalanceValue* _Nullable)nftAt:(long)at error:(NSError* _Nullable* _Nullable)error;
- (long)nftLength;
- (long)stx;
@end

@interface VDKBalanceKeys : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field BalanceKeys.FT with unsupported type: []string

// skipped field BalanceKeys.NFT with unsupported type: []string

@end

@interface VDKBalanceValue : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) VDKAsset* _Nullable asset;
@property (nonatomic) long amount;
@end

/**
 * Wrapper around [encoding/clarity.List].
 */
@interface VDKClarityList : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nullable instancetype)init;
- (void)add:(VDKClarityValue* _Nullable)value;
- (NSString* _Nonnull)raw;
- (void)setPrefix:(long)prefix;
- (void)setSubPrefix:(long)prefix;
@end

/**
 * Wrapper around [encoding/clarity.Value].
 */
@interface VDKClarityValue : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (NSString* _Nonnull)raw;
- (void)setPrefix:(long)prefix;
@end

/**
 * Wrapper around [transaction.Payload].
 */
@interface VDKPayload : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@end

/**
 * Wrapper around [transaction.Payload].
 */
@interface VDKPostCondition : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nullable instancetype)init;
/**
 * Add a FT PostCondition.
`code`:
		1 is ==
		2 is >
		3 is >=
		4 is <
		5 is <=
`amount`: total uSTX
`principal`: the destination (or if nil origin is assumed)
`asset`: the fungible token
 */
- (BOOL)addFT:(long)code amount:(long)amount principal:(VDKPrincipal* _Nullable)principal asset:(VDKAsset* _Nullable)asset error:(NSError* _Nullable* _Nullable)error;
/**
 * Add a NFT PostCondition.
`send`: sending (true) or no sending (false)
`principal`: the destination (or if nil origin is assumed)
`asset`: the non-fungible token
`value`: the identifying clarity value
 */
- (BOOL)addNFT:(BOOL)send principal:(VDKPrincipal* _Nullable)principal asset:(VDKAsset* _Nullable)asset value:(VDKClarityValue* _Nullable)value error:(NSError* _Nullable* _Nullable)error;
/**
 * Add a STX PostCondition.
`code`:
		1 is ==
		2 is >
		3 is >=
		4 is <
		5 is <=
`amount`: total uSTX
`principal`: the destination (or if nil origin is assumed)
 */
- (BOOL)addSTX:(long)code amount:(long)amount principal:(VDKPrincipal* _Nullable)principal error:(NSError* _Nullable* _Nullable)error;
- (NSString* _Nonnull)raw;
@end

/**
 * Wrapper around [address.Address].
 */
@interface VDKPrincipal : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Create a principal from a Stacks (c32) address.
 */
- (nullable instancetype)init:(NSString* _Nullable)value;
/**
 * Derive a bitcoin address (B58) from a [Principal].
 */
- (NSString* _Nonnull)bitcoin:(NSError* _Nullable* _Nullable)error;
/**
 * Derive a Stacks address (C32) from a [Principal].
 */
- (NSString* _Nonnull)stacks:(NSError* _Nullable* _Nullable)error;
@end

/**
 * Wrapper around [transaction.StacksTransaction].
 */
@interface VDKStacksTransaction : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Parse a Stacks Transaction (hex encoded).
 */
- (nullable instancetype)init:(NSString* _Nullable)raw;
@property (nonatomic) NSString* _Nonnull version;
@property (nonatomic) NSString* _Nonnull chainID;
@property (nonatomic) NSString* _Nonnull anchorMode;
@property (nonatomic) VDKPayload* _Nullable payload;
/**
 * Broadcast a Stacks Transaction to the Stacks network.
 */
- (BOOL)broadcast:(NSError* _Nullable* _Nullable)error;
/**
 * Encode a Stacks Transaction.
 */
- (NSString* _Nonnull)encode:(NSError* _Nullable* _Nullable)error;
/**
 * Estimate the fee of a Stacks Transaction.
 */
- (BOOL)estimateFee:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * Get the underlying Stacks transaction as a String.
 */
- (NSString* _Nonnull)raw;
- (void)setCondition:(VDKPostCondition* _Nullable)conditions strict:(BOOL)strict;
/**
 * Set the fee manually.
 */
- (void)setFee:(long)fee;
/**
 * Set the nonce manually.
 */
- (void)setNonce:(long)nonce;
/**
 * Sign a Stacks Transaction.
`account`: the account used to sign the transaction.
 */
- (BOOL)sign:(VDKAccount* _Nullable)account error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * Wrapper around [wallet.Wallet].
 */
@interface VDKWallet : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Derive a wallet from your mnemonic seed phrase with the option of using a password.
This implements [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md).
Note: Hiro wallet doesn't use a password only for encryption.
 */
- (nullable instancetype)initFromPhrase:(NSString* _Nullable)phrase password:(NSString* _Nullable)password;
/**
 * Derive a Stacks account from a [Wallet], index starting at 0.
 */
- (VDKAccount* _Nullable)account:(long)index error:(NSError* _Nullable* _Nullable)error;
/**
 * Get underlying Wallet as a String.
 */
- (NSString* _Nonnull)raw;
@end

/**
 * Create a new Asset (FT or NFT)
 */
FOUNDATION_EXPORT VDKAsset* _Nullable VDKNewAsset(VDKPrincipal* _Nullable contract, NSString* _Nullable name, NSError* _Nullable* _Nullable error);

/**
 * Retrieve the balance of a user.
 */
FOUNDATION_EXPORT VDKBalance* _Nullable VDKNewBalance(VDKPrincipal* _Nullable principal, NSError* _Nullable* _Nullable error);

FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityBool(BOOL content);

/**
 * TODO(Linden): change to `[]byte` when slice support is added to gomobile.
 */
FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityBuffer(NSString* _Nullable content);

FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityInt(long content);

FOUNDATION_EXPORT VDKClarityList* _Nullable VDKNewClarityList(void);

FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityOptional(VDKClarityValue* _Nullable content);

// skipped function NewClarityPrincipal with unsupported parameter or return types


FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityResponse(VDKClarityValue* _Nullable content, BOOL ok);

FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityStringASCII(NSString* _Nullable content);

FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityStringUTF8(NSString* _Nullable content);

FOUNDATION_EXPORT VDKClarityValue* _Nullable VDKNewClarityUInt(long content);

/**
 * Create a contract call.
`contract`: the principal of the contract.
`function`: the function being called.
`arguments`: arguments as a `ClarityList` or nil.
`conditions`: the post-conditions.
`strict`: has to follow post-condtions.
 */
FOUNDATION_EXPORT VDKStacksTransaction* _Nullable VDKNewContractCall(VDKPrincipal* _Nullable contract, NSString* _Nullable function, VDKClarityList* _Nullable arguments, NSError* _Nullable* _Nullable error);

/**
 * Generate a new mnemonic seed phrase for use with [NewWalletFromMnemonic].
We recommoned a length of 24 for maximum security and compatibility.
 */
FOUNDATION_EXPORT NSString* _Nonnull VDKNewPhrase(long length, NSError* _Nullable* _Nullable error);

FOUNDATION_EXPORT VDKPostCondition* _Nullable VDKNewPostCondition(void);

/**
 * Create a principal from a Stacks (c32) address.
 */
FOUNDATION_EXPORT VDKPrincipal* _Nullable VDKNewPrincipal(NSString* _Nullable value, NSError* _Nullable* _Nullable error);

/**
 * Create a new contract.
`account`: creator of the contract.
`name`: the name of the contract.
`body`: the contract source code.
`conditions`: the post-conditions.
`strict`: has to follow post-condtions.
 */
FOUNDATION_EXPORT VDKStacksTransaction* _Nullable VDKNewSmartContract(NSString* _Nullable name, NSString* _Nullable body, NSError* _Nullable* _Nullable error);

/**
 * Parse a Stacks Transaction (hex encoded).
 */
FOUNDATION_EXPORT VDKStacksTransaction* _Nullable VDKNewStacksTransaction(NSString* _Nullable raw, NSError* _Nullable* _Nullable error);

/**
 * Create a token transfer.
`recipient`: the destination of the funds can be a standard or contract principal.
`amount`: total uSTX sent.
`memo`: optional arbitrary info.
`conditions`: the post-conditions.
`strict`: has to follow post-condtions.
 */
FOUNDATION_EXPORT VDKStacksTransaction* _Nullable VDKNewTokenTransfer(VDKPrincipal* _Nullable recipient, long amount, NSString* _Nullable memo, NSError* _Nullable* _Nullable error);

/**
 * Derive a wallet from your mnemonic seed phrase with the option of using a password.
This implements [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md).
Note: Hiro wallet doesn't use a password only for encryption.
 */
FOUNDATION_EXPORT VDKWallet* _Nullable VDKNewWalletFromPhrase(NSString* _Nullable phrase, NSString* _Nullable password, NSError* _Nullable* _Nullable error);

#endif
